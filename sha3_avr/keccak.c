#include "keccakH.h"

// ////////////////////////////////////////////////////////////////////////////
void xor_block_to_state(void)
{
  // Опрацьовуємо по чотири байти за цикл
  
  // Зберігаємо Х
  asm("MOVW R17:R16, R27:R26");
  
  // Завантажуємо покажчики і лічильник
  asm("LDI R26,  LOW(msgBlock)");
  asm("LDI R27, HIGH(msgBlock)");
  asm("LDI R30,  LOW(state)");
  asm("LDI R31, HIGH(state)");
  
  // Число відповідає потрібній кількості опрацювання смуг помножити на 2
  asm("LDI R23, 32");
  
  // Цикл
  asm("xor_block_to_state_cycle:");
  
    // Опрацьовуємо перший байт
    asm("LD R21, X+");
    asm("LD R22, Z ");
    asm("EOR R22, R21");
    asm("ST Z+, R22");
    
    // Опрацьовуємо другий байт
    asm("LD R21, X+");
    asm("LD R22, Z ");
    asm("EOR R22, R21");
    asm("ST Z+, R22");
    
    // Опрацьовуємо третій байт
    asm("LD R21, X+");
    asm("LD R22, Z ");
    asm("EOR R22, R21");
    asm("ST Z+, R22");
    
    // Опрацьовуємо четвертий байт
    asm("LD R21, X+");
    asm("LD R22, Z ");
    asm("EOR R22, R21");
    asm("ST Z+, R22");
    
    // Зменшуємо лічильник
    asm("DEC R23");
  asm("BRNE xor_block_to_state_cycle");
  
  // Відновляємо X
  asm("MOVW R27:R26, R17:R16");
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
void cpy_hash_to_block(void)
{
  // Опрацьовуємо по чотири байти за цикл
  
  // Зберігаємо Х
  asm("MOVW R17:R16, R27:R26");
  
  // Завантажуємо покажчики і лічильник
  asm("LDI R26,  LOW(msgBlock)");
  asm("LDI R27, HIGH(msgBlock)");
  asm("LDI R30,  LOW(state)");
  asm("LDI R31, HIGH(state)");
  
  // Число відповідає потрібній кількості опрацювання смуг помножити на 2 
  asm("LDI R23, 9");
  
  // Цикл
  asm("cpy_hash_to_block_cycle:");
  
    // Опрацьовуємо перший байт
    asm("LD R22, Z+");
    asm("ST X+, R22");
    
    // Опрацьовуємо другий байт
    asm("LD R22, Z+");
    asm("ST X+, R22");
    
    // Опрацьовуємо третій байт
    asm("LD R22, Z+");
    asm("ST X+, R22");
    
    // Опрацьовуємо четвертий байт
    asm("LD R22, Z+");
    asm("ST X+, R22");
    
    // Зменшуємо лічильник
    asm("DEC R23");
  asm("BRNE cpy_hash_to_block_cycle");
  
  // Відновляємо X
  asm("MOVW R27:R26, R17:R16");
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// Доповнення останнього блоку
void padding(uint8_t tempLen)
{
  // Якщо лишається рівно-більше два вільні байти
  if ( (tempLen <= (RATE/8-2)) && (tempLen != 0) )
  {
    msgBlock[tempLen++] = 0x01;		// Додаємо 0х01
    for ( ; tempLen<(RATE/8-1); tempLen++)	// Додаємо потрібно к-сть нулів
    {
      msgBlock[tempLen] = 0x00;
    }
    msgBlock[tempLen] = 0x80;		// Додаємо останню 0х08
  }
  // В іншому випадку
  else
  {
    // Якщо залишається один вільний байт
    if (tempLen == (RATE/8-1))
    {
      msgBlock[tempLen] = 0x81;       // Додаємо 0х81
    }
    // В іншому випадку немає вільних байтів, наступний блок: 0х01,0х00,...,0х80
    else
    {
      tempLen = 0;
      msgBlock[tempLen++] = 0x01;	// Додаємо 0х01
      for ( ; tempLen<(RATE/8-1); tempLen++)	// Додаємо потрібно к-сть нулів
      {
        msgBlock[tempLen] = 0x00;
      }
      msgBlock[tempLen] = 0x80;	// Додаємо останню 0х08
    }
  }
}
// ////////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////////////////////////////////////
// Ініціалізація стану
void stateInit (void)
{
  uint8_t i;

  for (i = 0; i < LANES*DIV; i++)
    state[i] = 0;
}
// ////////////////////////////////////////////////////////////////////////////
